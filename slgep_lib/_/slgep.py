# -*- coding: utf-8 -*-
"""SL-GEP.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1ZQaxibtvqw8shzQDyDx6wgkkxKCbavfY
"""

import numpy as np

np.warnings.filterwarnings('ignore')
import random

# Hyper params of population
NP = 50  # Pop size
h_main = 10  # Head of main func
h_adf = 3  # Head of ADF
num_adfs = 2  # Number of ADF in each chromo
max_inputs = 2  # Maximum number of input for all functions and ADFs

l_main = h_main * (max_inputs - 1) + 1  # Tail of main func
l_adf = h_adf * (max_inputs - 1) + 1  # Tail of ADF
D = h_main + l_main + num_adfs * (h_adf + l_adf)  # Length of a Chromo

# Hyper params of the problem
# Function set
funcs = [
    {"name": "+", "func": lambda a: a[0] + a[1], "arity": 2},
    {"name": "-", "func": lambda a: a[0] - a[1], "arity": 2},
    {"name": "*", "func": lambda a: a[0] * a[1], "arity": 2},
    {"name": "/", "func": lambda a: a[0] / a[1], "arity": 2},
    {"name": "sin", "func": lambda a: np.sin(a[0]), "arity": 1},
    {"name": "cos", "func": lambda a: np.cos(a[0]), "arity": 1},
    {"name": "e^x", "func": lambda a: np.exp(a[0]), "arity": 1},
    {"name": "ln|x|", "func": lambda a: np.log(np.absolute(a[0])), "arity": 1}
]
# ADFs
adfs = [
    {"name": "ADF1", "func": None, "arity": max_inputs},
    {"name": "ADF2", "func": None, "arity": max_inputs}
]
# Variables
terminals = [
    {"name": "x", "value": 0, "arity": 0}
]
# Input of ADF
inputs = [
    {"name": "a", "value": 0, "arity": 0},
    {"name": "b", "value": 0, "arity": 0}
]

# Chromosome range
R1 = len(funcs)
R2 = R1 + len(adfs)
R3 = R2 + len(terminals)
R4 = R3 + len(inputs)


# | --- Base functions --- | --- ADF --- | --- Terminals --- | --- Input of ADF --- |
# 0 ---------------------- R1 ---------- R2 ---------------- R3 ------------------- R4

def set_terminals(_terminals):
    for i in range(len(terminals)):
        terminals[i]["value"] = _terminals[i]


def set_inputs(_inputs):
    for i in range(len(inputs)):
        inputs[i]["value"] = _inputs[i]


def get_feasible_range(ind):
    # Head of main, contains base functions and ADFs or a variable
    if ind < h_main: return 0, R3
    # Tail of main, contains variables
    if ind < h_main + l_main: return R2, R3
    # Head of ADF, contains base functions and ADF params
    if (ind - h_main - l_main) % (h_adf + l_adf) < h_adf:
        return 0, R1
    # Tail of ADF, contains ADF params
    else:
        return R3, R4


def random_assignment(ind):
    low, high = get_feasible_range(ind)
    return np.random.randint(high - low) + low


def print_chromosome(chromo):
    global_symbols = funcs + adfs + terminals + inputs
    s = ""

    for x in chromo:
        s += global_symbols[x]["name"] + " "

    return s


class GPNode:
    def __init__(self, value=0, arity=0, parent=None):
        self.value = value
        self.arity = arity
        self.parent = parent
        self.childs = []

    def add_child(self, child):
        self.childs.append(child)
        child.parent = self

    def is_full(self):
        return self.arity == len(self.childs)

    def get_value(self):
        # If the node is a leaf node, return its value
        if self.value >= R3: return inputs[self.value - R3]["value"]
        if self.value >= R2: return terminals[self.value - R2]["value"]
        # If it is a function or ADF node, we need to pass in its child as params
        params = []
        for child in self.childs:
            params.append(child.get_value())
        if self.value >= R1:
            set_inputs(params)
            return adfs[self.value - R1]["func"].get_value()
        return funcs[self.value]["func"](params)


class ADF:
    def __init__(self, gene):
        self.gene = gene
        self.root = None
        self.parse_tree()

    def parse_tree(self):
        global_symbols = funcs + adfs + terminals + inputs

        gene = self.gene.copy()
        queue = []
        queue.append(GPNode(gene[0], global_symbols[gene[0]]["arity"]))
        gene.pop(0)
        parent = None

        while (len(queue) != 0 and len(gene) != 0):
            parent = queue.pop(0)

            arity = parent.arity
            for i in range(arity):
                node = GPNode(gene[0], global_symbols[gene[0]]["arity"])
                queue.append(node)
                gene.pop(0)
                parent.add_child(node)

        while (parent.parent != None): parent = parent.parent
        self.root = parent

    def get_value(self):
        return self.root.get_value()


class Chromo:
    def __init__(self, gene):
        self.gene = gene.tolist()
        self.main = None
        self.parse_tree()

    def parse_tree(self):
        # Parse ADFs
        for i in range(num_adfs):
            head = h_main + l_main + i * (h_adf + l_adf)
            tail = head + h_adf + l_adf
            adfs[i]["func"] = ADF(self.gene[head:tail])
        # Parse the main program
        self.main = ADF(self.gene[0:h_main + l_main])

    def get_value(self, terminals):
        set_terminals(terminals)
        return self.main.get_value()


def discrete_distance(a, b):
    return 1 if a != b else 0


def get_frequencies():
    freqs = np.zeros(R4, dtype=int)
    for i in range(R4):
        freqs[i] = len(pop[pop == i])
    return freqs


def frequency_based_assignment(ind):
    # If the index belong to an ADF, use random assignment
    if ind >= (h_main + l_main): return random_assignment(ind)

    c0 = 1  # To ensure that a frequency 0 assignment can still occurs
    low, high = get_feasible_range(ind)
    freqs = get_frequencies()
    total_freq = np.sum(freqs[low:high]) + (high - low) * c0

    probs = np.zeros(high - low)

    for i in range(low, high):
        probs[i - low] = (freqs[i] + c0) / total_freq

    return np.random.choice(range(low, high), size=1, p=probs)[0]


# Root Mean Square Error
def get_rmse(gene):
    chromo = Chromo(gene)
    loss = 0
    for i in range(num_data):
        loss += np.square(chromo.get_value([X[i]]) - Y[i])
    loss = np.nan_to_num(loss, nan=num_data * 10000)
    return np.sqrt(loss / num_data)


def get_best_ind():
    errors = list(map(lambda x: get_rmse(x), pop))
    errors = np.nan_to_num(errors, nan=num_data * 10000)
    return np.argmin(errors)


# Data set
print("True objective function: x^6 - 2 * x^4 + x^2")
num_data = 200
X = np.random.uniform(low=-1, high=1, size=num_data)
Y = list(map(lambda x: np.power(x, 6) - 2 * np.power(x, 4) + x * x, X))

# Initialize the population
pop = np.zeros((NP, D), dtype=int)
for i in range(NP):
    for j in range(D):
        pop[i][j] = random_assignment(j)

num_iter = 1000000
solve_thresold = 0.001

for iter in range(num_iter):
    i_best = get_best_ind()  # Index of the best individual
    # Mutation
    for i in range(NP):
        u = pop[i].copy()

        F = np.random.rand()  # Scaling factor
        CR = np.random.rand()  # Crossover rate
        k = np.random.randint(D) + 1
        # Random 2 chromo in the population that are different from the current one
        i_1, i_2 = random.sample(list(range(0, i)) + list(range(i + 1, NP)), 2)

        for j in range(D):
            mu_prob = 1 - (1 - F * discrete_distance(pop[i_best][j], pop[i][j])) * (
                        1 - F * discrete_distance(pop[i_1][j], pop[i_2][j]))
            if (np.random.rand() < CR or j == k) and (np.random.rand() < mu_prob):
                u[j] = frequency_based_assignment(j)

        new_loss = get_rmse(u)
        best_loss = get_rmse(pop[i_best])
        # If the new child is better than its parent, replace the parent
        if new_loss < get_rmse(pop[i]):
            pop[i] = u
        # If the new child is the best, replace index of the best with the current index
        if new_loss < best_loss:
            i_best = i
            best_loss = new_loss

    print("Iter " + str(iter) + ", best ind " + str(i_best) + ", best loss " + str(best_loss))
    if best_loss < solve_thresold:
        print("Solved!")
        break

print("Best output" + print_chromosome(pop[i_best]))

print_chromosome(pop[11])

get_rmse(pop[11])
